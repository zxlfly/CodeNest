# 13.GLSL语法
GLSL 属于 GPU 层面的编程语言。主要是在 C 语言的基础上新增了一些内置变量、数据类型和数学函数，语法规则上和 C 语言基本相同。

- 大小写敏感
- 语句末尾必须有分号
- 以main函数为主体函数
- 注释语法和js一样
- 基本数据类型
   - 数字
      - float，例如1.0
      - int，例如1
   - 布尔型
      - true
      - false
## 变量
### 声明方法
在声明变量的时候应该指明变量类型
```glsl
float f=1.0;
int i=1;
bool b=true;
```
### 变量命名规范

- 只能包括a-z,A-Z,0-9,_
- 变量名首字母不能是数字
- 不能是GLSL 关键字，如attribute,vec4,bool
- 不能是GLSL 保留字，如cast,class,long
- 不能以下单词开头：gl_, webgl_, _webgl_
### 变量的赋值
和js一样使用=，=两边类型要一致
#### 基础数据的转换方法

- 浮点转整数：int(float)
- 布尔转整数：int(bool)
- 整数转浮点：float(int)
- 布尔转浮点：float(bool)
- 整数转布尔：bool(int)
- 浮点转布尔：bool(float)
## 向量
### 向量类型
支持2、3、4维向量，根据分量的数据类型，可以分为以下几类

- vec2、vec3、vec4：分量是浮点数
- ivec2、ivec3、ivec4：分量是整数
- bvec2、bvec3、bvec4：分量是布尔值
### 创建向量
```glsl
vec3 v3 = vec3(1.0, 0.0, 0.5);   // (1.0, 0.0, 0.5)
vec2 v2 = vec2(v3);              // (1.0, 0.0) 
vec4 v4 = vec4(1.0);             // (1.0,1.0,1.0,1.0)
vec4 v4b=vec4(v2,v4);             // (1.0,0.0,1.0,1.0)
```
### 向量分量的访问
#### 通过分量属性访问
```glsl
v4.x, v4.y, v4.z, v4.w  // 齐次坐标
v4.r, v4.g, v4.b, v4.a  // 色值
v4.s, v4.t, v4.p, v4.q  // 纹理坐标
```
#### 将分量的多个属性连在一起，获取多个向量
```glsl
vec4 v4 = vec4(1.0,2.0,3.0,4.0); 
v4.xy //(1.0,2.0)
v4.yx //(2.0,1.0)
v4.xw //(1.0,4.0)
```
#### 通过分量索引访问
```glsl
v4[0], v4[1], v4[2], v4[3]
```
#### 用上面的方法访问到向量后，也可以用=号为向量赋值
```glsl
v4.x=1.0
v4[0]=1.0
v4.xy=vec2(1.0,2.0)
```
## 矩阵
### 矩阵的类型
支持2、3、4维矩阵。矩阵中的元素都是浮点型。

- mat2
- mat3
- mat4
### 矩阵的建立
矩阵是列主序的，在建立矩阵的时候，其参数结构有很多种。
#### 浮点数，其参数是按照列主序排列的
```glsl
mat4 m=mat4(
    1,5,9,13,
    2,6,10,14,
    3,7,11,15,
    4,8,12,16
);
/*
    1,5,9,13,
    2,6,10,14,
    3,7,11,15,
    4,8,12,16
*/
```
#### 向量
```glsl
vec4 v4_1=vec4(1,2,3,4);
vec4 v4_2=vec4(5,6,7,8);
vec4 v4_3=vec4(9,10,11,12);
vec4 v4_4=vec4(13,14,15,16);
mat4 m=mat4(v4_1,v4_2,v4_3,v4_4);
/*
[
    1,2,3,4,
    5,6,7,8,
    9,10,11,12,
    13,14,15,16
]    
*/
```
#### 浮点+向量
```glsl
vec4 v4_1=vec4(1,5,9,13);
vec4 v4_2=vec4(2,6,10,14);
mat4 m=mat4(
    v4_1,
    v4_2,
    3,7,11,15,
    4,8,12,16
);
/*
    1,5,9,13,
    2,6,10,14,
    3,7,11,15,
    4,8,12,16   
*/
```
#### 单个浮点数
```glsl
mat4 m=mat4(1);
/*
矩阵中的参数数量大于1，小于矩阵元素数量，会报错
[
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1,
]    
*/
```
### 矩阵的访问

- 使用[] 可以访问矩阵的某一行
   - 虽然是列主序，拿出来的还是一行
- 使用 m[y][x] 方法，可以访问矩阵第y行，第x列的元素。
- m[y] 可以理解为一个向量，其内部的元素，可以像访问向量元素一样去访问。
   - 索引值的限制
      - 整形字面量，如0，1，2，3
      - 用const 修饰的变量
      - 循环索引
      - 单个int类型的变量是不可以的
## 运算符
和js类似
### 算术运算符
| **运算符** | **描述** | **例子** |
| --- | --- | --- |
| + | 加法 | x = y + 2 |
| - | 减法 | x = y - 2 |
| * | 乘法 | x = y * 2 |
| / | 除法 | x = y / 2 |
| ++ | 自增 | x = ++y |
|  |  | x = y++ |
| -- | 自减 | x = --y |
|  |  | x = y-- |

### 赋值运算符
| **运算符** | **描述** | **例子** |
| --- | --- | --- |
| = | 赋值等于 | x = y |
| += | 加等于 | x += y |
| -= | 减等于 | x -= y |
| *= | 乘等于 | x *= y |
| /= | 除等于 | x /= y |

### 比较运算符
| **运算符** | **描述** | **比较** |
| --- | --- | --- |
| == | 等于 | x == 8 |
| != | 不等于 | x != 8 |
| > | 大于 | x > 8 |
| < | 小于 | x < 8 |
| >= | 大于或等于 | x >= 8 |
| <= | 小于或等于 | x <= 8 |

### 条件运算符
| **语法** | **例子** |
| --- | --- |
| 布尔 ?值1:值2 | float f=2>3?1.0:2.0; |

### 逻辑运算符
| **运算符** | **描述** | **例子** |
| --- | --- | --- |
| && | 和 | true&&true=true; |
| &#124;&#124; | 或 | false&#124;&#124;true=true; true&#124;&#124;true=true; |
| ! | 非 | !false=true; |
| ^^ | 异或 | false^^true=true; true^^true=false; |

## 向量运算
向量可以与以下数据进行各种运算：

- 单独数字
- 向量
- 矩阵
### 向量和单独数字的运算
向量可以与单独数字进行加减乘除
```glsl
vec4 v=vec4(1,2,3,4);
v+=1.0;
v-=1.0;
v*=2.0;
v/=2.0;
```
vec4 是浮点型向量,其中的整数会被转换成浮点数。在做四则运算时，其用于运算的数字类型应该是浮点型。
整型向量的运算原理同上。
### 向量和向量的运算
向量和向量之间也可以进行运算，返回一个新的向量，前提是两个向量之间的维度必须相同。
运算规则是两个向量对应位置的元素分别进行运算。
#### 加减乘除
```
vec4 p=vec4(1,2,3,4);
vec4 v=vec4(2,4,6,8);
v+=p;
v-=p;
v*=p;
v/=p;
```
#### 其它方法

- distance(p0,p1) 向量距离
- dot(p0,p1) 点积
- cross(p0,p1) 叉乘
- ……
### 向量和矩阵的运算
矩阵只能与向量进行乘法运算。
向量乘以矩阵和矩阵乘以向量的结果是不一样的，但数据类型都是向量。
#### 矩阵乘以向量
矩阵乘以向量时，向量是几维的，那矩阵中就应该有几个向量。在webgl 里，矩阵元素的排列规则是列主序。
矩阵和向量相乘的规则就是让矩阵中的每个向量和向量相乘。
以列主序为例：矩阵乘以向量的运算是将矩阵的每一列与向量对应位置相乘，并将得到的结果相加，即矩阵的第一列与向量逐个元素相乘并相加，得到结果向量的第一个元素；矩阵的第二列同样与向量逐个元素相乘并相加，得到结果向量的第二个元素；以此类推
```
mat4 m=mat4(
    1,5,9,13,
    2,6,10,14,
    3,7,11,15,
    4,8,12,16
);
vec4 p=vec4(1,2,3,4);
vec4 v=m*p;

/*
    [30, 70, 110, 150]
*/
```
#### 向量乘以矩阵
```
vec4 v=p*m;

/*
    [90, 100, 110, 120]
*/
```
向量乘以矩阵时，向量是几维的，那矩阵中就应该有几个向量。向量和矩阵相乘的规则就是让矩阵中的每个向量和向量相乘。
以列主序为例：向量乘以矩阵的运算是将矩阵的每一行与向量对应位置相乘，并将得到的结果相加，即矩阵的第一行与向量逐个元素相乘并相加，得到结果向量的第一个元素；矩阵的第二行同样与向量逐个元素相乘并相加，得到结果向量的第二个元素；以此类推
#### 向量乘以向量
就是在求向量的点积，其结果是一个实数，而不再是向量。
## 矩阵运算
矩阵可以与以下数据进行各种运算：

- 单独数字
- 向量
- 矩阵
### 矩阵和单独数字的运算
等于矩阵每个元素和单独数字运算
```
mat4 m=mat4(
    1,5,9,13,
    2,6,10,14,
    3,7,11,15,
    4,8,12,16
);
m+=1.0;
m-=1.0;
m*=2.0;
m/=2.0;
```
### 矩阵和矩阵的运算
矩阵和矩阵之间可以进行加减乘除
#### 矩阵加法：相同索引位置的元素相加
#### 矩阵减法：相同索引位置的元素相减
#### 矩阵除法：相同索引位置的元素相除
#### 矩阵乘法
行主序的情况下和列主序的情况下，两个矩阵相乘，计算公式过程是一样的吗？？？
第一个矩阵的行与第二个矩阵的列相乘。矩阵的乘法交换律一般是不成立的。 结合律是成立的。

- 左边矩阵每一列去乘以右边矩阵的每一行
- 取出左边的一列，依次乘以右边的每一行
- 每乘以右边的一列结果相加就是结果矩阵当前列的其中的一个数

矩阵相乘的前提条件：

- 第一个矩阵的行数=第二个矩阵的列数 
   - 因为第一个矩阵的行数决定了每一列有多少个元素，第二个矩阵的列数决定了每一行有多少个元素，只有两者相等的时候才能计算
   - 如果A_B有意义的话，那么B_A不一定有意义的。
   - 两个矩阵可交换的前提是要求这两个矩阵是同阶方阵 
      - AB=BA 的前提是A、B是同阶方阵
      - A(2_2)B(2_2)=B(2_2)A(2_2)
- 结果矩阵的形状 
   - 结果矩阵的行数=第一个矩阵的行数
   - 结果矩阵的列数=第二个矩阵的列数
- 矩阵与单位矩阵相乘： 
   - 结果还是自己
## struct
结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员
结构体允许你创建自定义的数据类型，以便更好地组织和管理着色器中的数据。你可以在结构体中包含各种类型的变量，例如向量（vec）、矩阵（mat）、浮点数（float）等，以满足特定需求。
和JavaScript中的对象（Object）类似
#### 定义结构体
在着色器程序中，你需要定义结构体的类型，指定该类型的名称和包含的成员。
struct 结构体名{
    结构体所包含的变量或数组
};
```glsl
struct Light {
    vec3 position;
    vec3 color;
    float intensity;
};
```
#### 声明结构体变量
在着色器中，你可以声明结构体变量来使用它们。
```glsl
Light light1;

```
#### 初始化结构体变量
你可以使用赋值运算符初始化结构体变量的成员。
```glsl
light1.position = vec3(1.0, 2.0, 3.0);
light1.color = vec3(1.0, 1.0, 1.0);
light1.intensity = 0.8;
```
#### 访问结构体成员
使用点运算符（.）可以访问结构体变量的成员。
```c
vec3 lightPosition = light1.position;
vec3 lightColor = light1.color;
float lightIntensity = light1.intensity;
```
## 数组
glsl 中的数组具有以下特性：

- 属于类型数组
- 只支持一维数组
- 不支持pop()、push() 等操作
### 创建数组
在建立某个类型的数组时，在数据类型后面加[]即可，[]中要写数组的长度
数组的长度需要按照以下方式定义

- 整形字面量
   - ``vec4 vs[2];``
- const 限定字修饰的整形变量
   - ``const int size=2;vec4 vs[size];``
- 不能是函数的参数
```
vec4 vs[2];
vs[0]=vec4(1,2,3,4);
vs[1]=vec4(5,6,7,8);
```
### 数组需要显示的通过索引位置一个元素、一个元素的赋值
```
vs[0]=vec4(1,2,3,4);
vs[1]=vec4(5,6,7,8);
```
### 数组中的元素需要用整形的索引值访问
```
gl_FragColor=vs[1]/255.0;
```
## 程序流程控制
### if 判断
glsl 中的if 判断和js 里的if 写法是一样的。都有一套if、else if、else 判断。
if太多会降低着色器执行效率，glsl中也没有switch语句
```
float dist=distance(gl_PointCoord,vec2(0.5,0.5));

if(dist>=0.0&&dist<0.125){
    gl_FragColor=m[0]/255.0;
}else if(dist>=0.125&&dist<0.25){
    gl_FragColor=m[1]/255.0;
}else if(dist>=0.25&&dist<0.375){
    gl_FragColor=m[2]/255.0;
}else if(dist>=0.375&&dist<0.5){
    gl_FragColor=m[3]/255.0;
}else{
    discard;
}
```
### for 循环
glsl 中的for循环和js类似；
for(初始化表达式; 条件表达式; 循环表达式){
循环体;
}
for循环的基本规则如下：

- 循环变量只能有一个，只能是int或float 类型。
- 在循环体中也可以使用break或continue，其功能和js一样。
```
float dist=distance(gl_PointCoord,vec2(0.5,0.5));
for(int i=0;i<4;i++){
    float r1=0.125*float(i);
    float r2=r1+0.125;
    if(dist>=r1&&dist<r2){
        gl_FragColor=m[i]/255.0;
        break;
    }else if(i==3){
        discard;
    }
}
```
## 函数
### 函数的建立
函数类型 函数名(形参){
函数内容;
return 返回值;
}
```html
<script id="fragmentShader" type="x-shader/x-fragment">
    precision mediump float;
    float getLum(vec3 color){
      return dot(color,vec3(0.2126,0.7162,0.0722));
    }
    void main(){
      vec3 color=vec3(255,255,0);
      float lum=getLum(color);
      vec4 v=vec4(vec3(lum),255);
      gl_FragColor=v/255.0;
    }
</script>
```
### 函数的声明
我们也可以将函数体放到其调用方法的后面，不过在调用之前得提前声明函数。
```
precision mediump float;
float getLum(vec3);
void main(){
    vec3 color=vec3(255,255,0);
    float lum=getLum(color);
    vec4 v=vec4(vec3(lum),255);
    gl_FragColor=v/255.0;
}
float getLum(vec3 color){
    return dot(color,vec3(0.2126,0.7162,0.0722));
}
```
### 参数限定词
我们通过参数限定词，可以更好的控制参数的行为。
参数的行为是围绕参数读写和拷贝考虑的。
我们通过参数的限定词来说一下参数行为：
#### in 参数深拷贝，可读写，不影响原始数据，默认限定词
```glsl
precision mediump float;
void setColor(in vec3 color){
  color.x=0.0;
}
void main(){
  vec3 color=vec3(255);
  setColor(color);
  vec4 v=vec4(color,255);
  gl_FragColor=v/255.0;
}
```
#### out 参数浅拷贝，可读写，影响原始数据
```glsl
void setColor(out vec3 color){
  color.x=0.0;
}
```
#### const in 常量限定词，只读
```glsl
void setColor(in vec3 color){
  float r=color.r;
}
```
#### inout 功能类似于out，用得不多，知道即可
用于指定函数参数既作为输入（in）又作为输出（out）的参数。通过使用inout限定词，函数可以修改传递给它的参数，并将修改后的值传回调用者。
```glsl
// 自定义函数，使用inout参数限定词
void modifyValue(inout float value) {
  value = value * 2.0;
}

void main() {
  float myValue = 3.0;
  modifyValue(myValue);
  // 此时myValue的值为6.0，因为函数modifyValue修改了传递给它的参数值
}
```
### 内置函数
GLSL提供了许多内置函数来执行各种常见的数学和图形操作。这些函数可以在所有的着色器阶段中使用。一些常见的内置函数包括：

- 数学函数：如sin、cos、sqrt等。
- 向量和矩阵函数：如length、normalize、dot等。
- 几何函数：如cross、reflect、refract等。
- 纹理函数：如texture、textureProj、textureLod等。
```glsl
vec2 position = vec2(0.5, 0.5);
float distance = length(position); // 计算向量长度
```
## 作用域

- 全局作用域
- 函数作用域
- 块级作用域
- 结构作用域
## 变量的作用域
变量的作用域指的是变量在程序中可见和可访问的范围。和js的es6类似
### 全局作用域
全局作用域的变量在整个程序中都可见和可访问。它们可以在任何函数内部使用，并且对程序中的所有函数都是可见的。
```glsl
float globalVariable; // 全局作用域变量

void myFunction() {
    // 可以访问全局作用域的变量
    float result = globalVariable + 10.0;
}
```
### 函数作用域
函数作用域的变量仅在声明它们的函数内部可见和可访问。这些变量只在其所属的函数内部有效
```glsl
void myFunction() {
  float localVar; // 函数作用域变量

  // 只能在该函数内部使用
  localVar = 20.0;
}

```
### 块作用域
块作用域的变量仅在声明它们的代码块（如if语句、for循环等）内部可见和可访问。它们的生命周期限定在该代码块及其子块内部。
```glsl
void myFunction() {
    if (condition) {
        float blockVar; // 块作用域变量

        // 只能在该块内部使用
        blockVar = 30.0;
    }

    // 在这里无法访问blockVar
}

```
### 结构作用域
结构作用域的变量仅在声明它们的结构体内部可见和可访问。它们只能在同一结构体中使用，并且对结构体外部的其他代码是不可见的。
```glsl
struct MyStruct {
    float structVar; // 结构作用域变量
};

void myFunction() {
    MyStruct myStruct;
    myStruct.structVar = 40.0; // 可以访问结构作用域的变量
}
```
## 精度限定词
精度限定词可以提高着色程序的运行效率，削减内存开支。
### 精度的分类
webgl 提供了三种精度：

- highp 高精度
- mediump 中精度
- lowp 低精度

一般中精度用得会比较多，因为高精度太耗性能，而且有时候片元着色器会不支持，而低精度又太low。
### 精度的定义方法
我可以为某个变量设置精度，也可以为某种数据类型设置精度。
####  设置某个变量的精度
```
mediump float size;
highp vec4 position;
lowp vec4 color;
```
#### 设置某种数据类型的精度
```
precision mediump float;
precision highp int;
```
着色器中，除了片元着色器的float 数据没默认精度，其余的数据都是有默认精度的。
因此，我们在片元着色器里要提前声明好浮点型数据的精度。
