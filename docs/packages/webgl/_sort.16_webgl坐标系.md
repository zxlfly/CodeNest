# webgl坐标系
WebGL 把 3D 世界中的模型（物体）渲染到屏幕上，其中的最大难点就是坐标系的变换。其中会涉及到多种坐标系，每种坐标系都有自己的功能意义。
## 顶点渲染到屏幕的过程
CPU通过js将顶点的数据传递给GPU，然后赋值给gl_Position，这个过程中一般会有坐标的转换，通常在js中完成。
gl_Position接受一个四维向量表示坐标，XYZW，W不为0，这个坐标是在裁剪坐标系中，所以我们称之为裁剪坐标。
GPU得到裁剪坐标之后会对坐标进行透视除法，为了将顶点转换到NDC设备独立坐标系中。所谓透视除法就是将裁剪坐标的各个分量同时除以 W 分量。 NDC 坐标系是一个边长为 2 的正方体，超出正方体的顶点都将被抛弃，不会显示到屏幕上。
接下来GPU就要将顶点绘制到屏幕上了，但是NDC 坐标和屏幕坐标不一样，需要坐标变换。将顶点坐标从NDC转换到屏幕坐标系中，最终显示在屏幕上。
## 坐标系分类
按照转换顺序以及是否可以通过js控制将坐标系分为下面两大类：

- js可以操作的，也就是在cpu中处理的
   - 从起始的顶点开始，顶点在**模型坐标系**中
      - 进过模型变换转换到**世界坐标系**中
   - 然后通过相机所在的**观察坐标系**观察物体
      - 将物体从世界坐标系转换到**观察坐标系**中
   - 最后经过投影变换
      - 将物体从观察坐标系转换到**裁剪坐标系**
- js不可以操作的，GPU 接收CPU 传递过来的裁剪坐标
   - 通过透视除法
      - 将裁剪坐标转换为**NDC（设备独立坐标系）**坐标
   - 最后通过视口变换完成渲染

所有的坐标系依次为：

- **模型坐标系**
- **世界坐标系**
- **观察坐标系**
- **裁剪坐标系**
- **NDC（设备独立坐标系）**
- **屏幕坐标系**
### 模型坐标系

- 一个基于模型本身的坐标系，描述了各个点在模型中的位置，并不关心模型最终会被放在哪里。一般坐标的原点在模型的正中心。
- 遵循右手坐标系。
### 世界坐标系

- 用来描述整个3d场景的坐标系，原点在（0，0，0）
- 将模型放在世界坐标系中默认就会在原点位置，这肯定不是我们想要的，此时将模型转换到世界坐标系中我们希望的位置就需要通过**模型变换**来实现
- 遵循右手坐标系。
### 观察坐标系

- 又被称为相机坐标系，用来模拟相机或者说是人眼观察世界的结果
   - 就是为了模拟我们日常人眼视物的效果，这个观察操作更贴合我们日常习惯
   - 显示的时候也只显示人眼能看到的部分，这样我们通过改变人眼的位置所看的方向，从而看到整个3D空间不同的部分。
- 默认规定以相机的位置为坐标原点，拍（看）的方向为Z轴负方向
- 将世界坐标系经过**视图变换**就能转换到观察者坐标系中
- 将相机放在世界坐标系中不同的位置，拍不同的方向，就会有不一样的视图变换矩阵，世界坐标系中同一个点，在观察坐标系中的坐标就会不一样。就像我们站在不一样的地方观察一样，看到的画面也会不一样。
- 遵循右手坐标系。
### 裁剪坐标系

- 将观察坐标进行**投影变换**得到的就是裁剪坐标，就是gl_Position接受的坐标
- 对坐标进行归一化处理【-1.0 , 1.0】。
- 用来限制可视范围以及后续将3d转换成2d做准备
- 此时需要定义一个可视范围，这个范围由投影变换矩阵定义。
- 注意下面提到的透视除法不是在计算裁剪坐标使用的，是将裁剪坐标转换成NDC的时候使用的
- 将**观察坐标系**转换到**裁剪坐标系，**需要进行**投影变换**，这个过程中用到的矩阵就是**投影变换矩阵**。一般有两种：
   - 正交投影矩阵（正交投影）
      - 通过定义一个长方体来控制可视范围，在这个长方体内的点都会最终被显示到屏幕上
      - 经过投影变换之后，坐标会增加一个w分量（0,0,0,w），这个w分量会在后续的变换中会用到，用来描述一个点离观察点（观察坐标系的原点）的距离所带来的影响。这个w分量的引入就是裁剪坐标系所做的第二件事：为后续将3d世界转成2d世界做准备。
      - 在正交投影中，这个w分量始终为1，代表离观察点（人眼/摄像机）的距离不会带来任何影响。
         - 所以在经过透视除法后物体的轮廓比例不会发生改变，不符合人眼观察世界所产生的近大远小的规律
   - 透视投影矩阵（透视投影）
      - 模拟人眼近的东西看着大，可见范围小，远的看着小，可见范围大
      - 可视范围是一个锥体。
      - 经过投影变换之后，坐标会新增一个w分量。与正交投影不同，这个分量不始终唯一，而是离观察点越远的点，w分量越大，
- 遵循左手法则

w分量保留之前投影的计算结果，利用它，在后续变换中只要简单地计算即可得到在2d屏幕上的坐标。它主要保留了两个信息：投影变换后坐标的大小信息以及离观察点远近的距离信息。

- 大小信息：w 分量随着离观察者的距离而改变。离观察者远的物体其 w 值较大，使得经过透视除法后其标准化坐标（x/w, y/w, z/w）的值较小。这样，在屏幕上显示时，离观察者远的物体会变小，产生近大远小的透视效果。因此，w 分量保留了物体的大小信息，使得投影后的物体能够按照远近透视进行正确呈现。
- 距离信息：w 分量也反映了物体到观察点的距离。离观察者更远的物体其 w 值较大，而离观察者近的物体其 w 值较小。这个距离信息对于一些后续变换或渲染操作非常有用。例如，在深度测试（depth testing）中，可以使用 w 分量来判断物体之间的遮挡关系，确保只有最前面的物体才可见。此外，还可以根据 w 分量的值进行一些特效的计算，如深度模糊效果。
### 规范化的设备坐标系（NDC）

- 屏幕设备各种各样，我们需要一个统一的坐标系去描述我们的一个点需要渲染在屏幕的哪个位置，这个坐标系就是范化的设备坐标系
- 所有顶点坐标都被变换到裁剪坐标系，GPU就会对其进行透视除法，将裁剪坐标系转换到NDC
   - 它只是简单的对坐标进行除法运算，将xyz三个分量分别处以w分量，得到新的xyz分量。
   - 距离观察点越远，w越大，经过除法后xyz越小，xy变小意味了大小变小，z变小意味着离观察点远，z更大的会覆盖在z更小的上面，这也就把w所保留的信息恢复了出来。
- 遵循左手法则
### 屏幕坐标系

- 规范化的设备坐标系范围在-1到1之间，绘制到屏幕需要需要转换
- 屏幕坐标系描述了真实的屏幕空间，将NDC坐标系转换到屏幕坐标系需要用到**视口变换**。视口变换矩阵定义了屏幕坐标与NDC坐标的对应关系，不同分辨率的屏幕会有不同的视口变换矩阵。
- 遵循右手法则
## 坐标变换
这些坐标系之间的转换就需要通过矩阵来实现，这个过程中需要注意的是矩阵是不满足乘法交换律的，因此这样坐标的转换是固定顺序的，可以形象的称之为坐标系转换流水线。
  
![](https://cdn.nlark.com/yuque/0/2023/jpeg/26796231/1687339677156-15106c3e-c694-4672-ac0a-82125dae3f82.jpeg)
### 转换例子
以一个模型中的点A为例
#### 模型坐标系
假设现在有一个边长为5的立方体模型，A就在这个模型中 ，模型的原点为（0，0，0），A点在（5，5，0）这个位置
#### 世界坐标系
一般默认情况下，模型坐标系和世界坐标系会重合在一起，此时A的世界坐标还是（5，5，0），模型的原点为（0，0，0）。
如果我们把这个立方体沿着X轴和Y轴各位移5个单位距离，那么模型的原点为（5，5，0），A的坐标为（10，10，0）
#### 观察坐标系
世界坐标系中有个人在B点（2，2，0）位置观察这个立方体。因为B所在的观察坐标系中此时XY方向一致，只是Z轴方向相反（看向的方向为-Z），所以将世界坐标系的原点转换到观察者坐标系中就是（-2，-2，0）。
因此此时A点在观察坐标系中的坐标为（8，8，0）
#### 裁剪坐标系
这里方便计算我们使用正交投影，所以W分量的值为1。设置观察范围为左侧坐标 -8，右侧坐标 8，上方坐标 8，下方坐标 -8，近平面坐标 0， 远平面坐标 8，处在这个范围内的顶点都将被转换到裁剪坐标系中。
因此X轴和Y轴的缩放因子 = 2 / (8 - (-8)) = 2 / 16 = 1/8，Z轴的缩放因子 =  2 / (8 - 0) = 1/4。然后再将点 A 的 X、Y、Z 坐标分别乘以对应的缩放因子，得到缩放后的坐标为 (1, 1, 0)。最后加上W分量得到的结果为（1，1，0，1），即裁剪坐标系中的坐标。

#### NDC坐标系
将裁剪坐标执行透视除法，所以A点坐标为（1，1，0，1）
#### 屏幕坐标系
需要进行视口变换，视口使我们通过webgl的gl.viewport  api来设置的，假如我们将宽高分别设置为500，300。那么接下来GPU就会将NDC坐标转换到视口范围内，也就是将【-1，1】的立方体范围内的坐标映射到500*300的屏幕坐标范围内。

- 首先找到NDC坐标系原点在屏幕坐标系中的坐标位置
   - 屏幕坐标系原点在左上方Y轴方向相反
   - NDC的范围是【-1，1】，所以原点位置的屏幕坐标为（250，150）
   - 需要注意的是由于Y轴方向是相反的，所以计算的时候NDC 坐标系下的 Y 轴坐标转化到屏幕坐标系时要取Y轴坐标的相反数
- 顶点A的坐标
   - 先将值转换过来XY为（250，-150）
   - 然后加上原点位置的变换
      - （500，0）

最终的结果在右上角。
至此整个坐标系和转换的基本概念已经介绍完毕了，后续会结合矩阵来进行计算。
