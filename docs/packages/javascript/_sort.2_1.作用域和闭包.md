# 作用域是什么

作用域是一套规则，用于确定在何处以及如何查找变量。即变量的可用范围，防止不同范围内的变量相互干扰。  

- js作用域有3级：全局、函数和块级作用域。
- 全局作用域：
  - 不属于任何函数的外部范围
  - 保存在全局的变量被称为全局变量
- 函数作用域
  - 一个函数范围内的作用域
  - 保存在函数范围内的变量成为局部变量
  - 形参也是函数内的局部变量
  - 函数作用域只有当函数执行的时候才会创建
    - this对象就是存在其中
    - 执行完毕会立即回收内存
    - 这是理解闭包的基础
- **关于块级作用域**
  - JavaScript中的块级作用域是通过let和const关键字来实现的，**而不是说任何一对花括号{}都会自动创建一个新的作用域**。在使用let和const声明变量时，这些变量的作用域被限制在包含它们的最近的代码块内。
    - 在全局下声明，在全局window中也无法找到

## 编译原理

- 分词/词法分析
  - 将字符串也就是我们的代码，分解成有意义的代码块
  - 这些代码块被称为**词法单元**
  - 例如``var z = 1;``
    - 词法单元有：var,a,=,2,;
  - 分词和词法分析之间是有区别的
    - 主要在于词法单元的识别是通过**有状态**还是**无状态**的方式进行。
    - 如果词法单元生成器在**判断a是一个独立的词法单元还是其他词法单元一部分的时候**，调用的是**有状态的解析规则**，那么这个过程就是词法分析
    - 上面提到的**有状态的解析规则**指的是**状态机**
    - **状态机**
      - 状态机不是机器设备，而是一个数学模型
      - 涉及到State 状态，Event 事件，Action 动作，Transition 转换
      - 上面这四大概念，在使用状态机思想来写程序时候经常用到
      - 想要改变状态就需要通过事件触发动作从而通过转换来改变状态。
- 解析/语法分析
  - 将上面得到的词法单元流（数组）转换成一个代表了程序语法结构的树--抽象语法树AST
- 代码生成
  - 将AST转换成为可执行代码的过程
  - 就是转化为机器可以运行的指令

**JavaScript的编译过程不是发生在构建的时候，而是在代码执行前很短的时间内完成。简单来说就是执行前要进行编译，然后就要执行。**

### 编译原理小结

- 分词/词法分析
  - 将我们写的代码分解成有意义的代码块--词法单元
- 解析/语法分析
  - 将上面得到的词法单元流数组，转换成一个代表了程序语法结构的树--抽象语法树AST
- 代码生成
  - 将AST转换成机器可以执行的指令  

**js的编译过程不是发生在构建的时候，而是在代码执行前很短的时间内完成的。**

## 理解作用域

三个角色

- 引擎
  - 从头到尾负责整个的编译执行过程
- 编译器
  - 负责语法分析及代码生成等
- 作用域
  - 负责收集维护变量
  - 并且有一套严格的规则，控制着权限

还是以``var z = 1;``开头理解js处理的过程
引擎处理的时候分两步：  
1.由编译器在编译的时候处理  
2.引擎在运行时处理  

- 遇到``var z``编译器会询问作用域，在同一作用域集合内是否存在这个变量
  - 如果存在，则忽略声明，继续进行编译
  - 否则会要求在当前作用域集合中声明一个新的变量，命名为``z``
- 接下来就是生成引擎运行时所需要的代码
  - 这些代码会处理``z = 1``这个赋值操作
- 引擎运行时会先询问作用域
  - 在当前作用域集合中是否存在``z``
    - 存在，引擎会使用这个变量
    - 不存在，引擎会继续查找（向上一级）
      - 如果最后找到了，会将1赋值给它
      - 否则会抛出异常  

**总结**：**变量赋值的操作会执行两个步骤，首先，如果变量在当前作用域集合中不存在，就声明一个，否者跳过声明；然后在运行时引擎会在作用域集合中查找该变量，如果能找到就会对他赋值。**

**关于引擎执行代码**
以上面的例子来说，引擎会做两个操作``LHS``、``RHS``。

- ``LHS``是赋值操作的左侧操作
  - 查找变量容器本身，操作的目标
- ``RHS``是赋值操作的右侧操作
  - 就是查找值，赋值的源头
- 函数声明并不符合变量操作
  - 它是在编译阶段代码生成的同时处理声明和值的定义
  - 所以在引擎执行代码的时候，不会有线程专门的将函数值分配给函数名


### 例子

```
function foo(a){
  console.log(a)
}
foo(2)
```

整个过程：
引擎：作用域,我需要foo进行RHS引用，有吗  
作用域：有，编译器声明了它，是一个函数，给你  
引擎：执行foo  
引擎：作用域，我需要对这个函数形参a进行LHS，有吗  
作用域：有，编译器将他声明成了foo的形参  
引擎：把2赋值给a
引擎：作用域，我要为console做RHS，有吗  
作用域：有，是个内置对象  
引擎：看看里面是不是有log(..)，有，是一个函数
引擎：作用域，我需要对a进行RHS  
作用域：这个变量没有动过  
引擎：把a的值2传递进log(..)  

### 赋值小结

变量的赋值操作分两步：

- 首先，如果变量在当前作用域集合中不存在，则声明变量，否则就跳过声明 
  - 查找变量容器本身，操作的目标
- 然后在运行引擎会在作用域集合中查找该变量，如果能找就对其赋值。 
  - 如果直接对未声明的变量赋值，会默认将该变量声明到全局
  - 如果直接对未声明的变量进行运算操作等，会报错。
- 函数并不符合变量操作 
  - 函数式声明的函数，是在编译阶段代码生成的同时处理声明和值的定义

## 作用域嵌套（作用域链）

当一个块或者函数嵌套在另一个块或者函数中时。就会发生作用域嵌套。因此，在当前作用域找不到某个变量的时候，引擎就会依次的向外层查找，直到找到，或者到最外层为止（即全局作用域）。LHS和RHS都是在当前楼层查找，没有就会去上一层，以此类推，这就是**作用域链**。  
这种向上查找的方式是js规定的，一个函数既能使用自己的作用域的变量，又能用外层作用域的变量。所以每个函数在定义的时候，作用域链就已经生成了。一个函数可以使用的作用域串联起来就是形成了作用域链。

### 作用域链小结

js是词法作用域，就是由写代码时将变量和函数写在哪决定的。
当一个块或者函数嵌套在另一个块或者函数中时，就会发生作用域嵌套。因此在当前作用域下查找某个变量时，引擎就会依次向外层查找，直到找到，或者到全局，这就是作用域链。

## 异常

上面讲的都是理想状态，如果在变量没声明的情况下就调用，就会出问题。

```
function foo(a){
  console.log(a+b)
  b=a
}
foo(1)
```

第一次对b进行RHS的时候是无法找到变量的，引擎会抛出``referenceError``异常。  
如果是执行LHS的时候发现没有，就会在全局作用域中创建一个，并将其返回给引擎。前提是不在严格模式下。

## 词法作用域

词法作用域就是定义在词法阶段的作用域。就是由你在写代码时将变量和块作用域写在哪里来决定的。  
因此大部分情况下，词法分析器处理代码时会保持作用域不变。会有一些特殊的方法可以在词法解析器处理过后依然可以修改作用域。  

## 欺骗词法（不推荐使用）

### eval

这个方法可以接受一个字符串参数，并且将其视为就是写在这个位置的代码。也就是说里面涉及到有关作用域的操作，引擎会默认的在当前位置作用域查找操作。  
例如：

```
function foo(str,a){
  eval(str)
  console.log(a,b)
}
var b = 2
foo('var b = 6',1)
//1,6
```

上面代码在执行的时候会在foo作用域下声明一个变量b，这样外部的b就被屏蔽掉了。  
但是在严格模式下，eval有自己的词法作用域，也就意味着不能修改所在的作用域。  
setTimeout和setInterval第一个参数也可以是字符串，内容可以被解析为一段动态生成的代码。  
new Function(..)的行为也很类似，最后一个参数可以接受字符串，并将其转换成动态生成的函数。  
在webpack编译之后输出的文件里面其实就用到了eval，但是实际开发中还是不要动态生成代码，尽量不要用。会有性能损失。

### with

它通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。  
例如：

```
var obj = {
  a:1,
  b:2,
  c:3
}
//普通做法
obj.a=2
obj.b=3
obj.c=4
//with
with(obj){
  a=3;
  b=4;
  c=5;
}
```

副作用例子：

```
var obj1={
  a:3
}
var obj2={
  b:3
}
function foo(obj){
  with(obj){
    a=2
  }
}
foo(obj1)
console.log(obj1.a)//2
foo(obj2)
console.log(obj2.a)//undefind
console.log(a)//2
```

当是obj1的时候a=2找到了obj1.a，所以结果是2；但是obj2的里面是没有a的，没有找到，让后去上一级找也就是全局也没有，所以他就在全局创建了一个。  
虽然with可以将一个对象处理为词法作用域，但是这个块内部的var声明不会被限制在这个快的作用域中，而是被添加到with所在的函数作用域中。  
严格模式下with被禁止使用。 

### 欺骗词法小结

词法分析器在处理代码时会保持作用域不变，但是会有一些特殊的方法可以在词法分析器处理过后依然可以修改作用域。

- eval
  - 这个方法可以接受一个字符串参数，并且将其视为就是写在这个位置的代码。也就是说里面涉及到作用域的操作，引擎会默认在当前作用域查找操作。
- with
  - 通常当做重复引用一个对象中多个属性的快捷方式，可以不需要重复的引用对象本身。

### 性能

js引擎会在编译阶段进行数项性能优化。其中有些优化依赖于能够**根据代码的词法进行静态的分析**，并**预先确定所有变量和函数的定义位置**，才能在执行过程中快速的找到标识符。  
但是如果引擎在代码中发现了eval或with，他只能简单的假设关于标识符的判断都是无效的，因为无法在词法分析阶段明确知道会接受到什么代码。  

**总结**：词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何进行查找。

## 函数作用域和块作用域

**函数作用域**指，属于这个函数的全部变量都可以在整个函数的范围内使用以及复用。

区分函数声明和表达式最简单的方法就是看function的位置：

- 如果function是声明中的第一个词，那么就是一个函数声明
- 否则就是函数表达式

## 提升

引擎在解释js代码之前，会先对其进行编译。编译阶段会找到所有的声明，定义声明它们，用合适的作用域关联起来。赋值相关操作会留在原地等待执行阶段。  
这个过程就好像声明被从原来的位置移动到了最上面，这个过程就叫做提升。  
先有声明，后有赋值。函数的声明一样。  
在这个过程中函数优先，也就是说函数会首先被提升，然后才是变量。  
函数声明有两种方式：

- 函数式即function为第一个关键词
  - 这种方式就包括了函数体
  - 也就是说可以在代码之前调用函数
- 声明式即function不是第一个关键词，例如声明变量接受
  - 这时提升的是指变量，函数表达式会在原地等待执行阶段。
  - 赋值之前调用会报错

提升是在同一作用域下，如果重名后面的赋值覆盖前面的。

## 作用域闭包

当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。
例如：

```js
// 用外层函数包裹要保护的变量，和操作使用变量的内层函数
function foo(){
  var a = 1
  function bar(){
    console.log(a)
  }
  // 在外层函数内部返回内层函数
  return bar
}
// 调用外层函数，用变量接住返回的内存函数对象
var baz = foo()
baz()//2
```

这就形成了一个闭包。  
函数bar()的词法作用域能够访问foo()的内部作用域，然后我们又将bar()函数本身当做返回值;  
函数foo()执行后，其返回值赋值给baz并且调用bar()，实际上只是通过不同的标识符引用调用了内部的函数bar();  
foo()执行后通常会期待foo()的整个内部作用域被销毁，因为引擎有垃圾回收机制，会释放不再使用的内存空间。  
但是bar()在使用，所以无法销毁。  
因为bar声明在foo()内部，bar()之后的调用需要能访问foo()的内部作用域。  
也就是bar()依然保持着对该作用域的引用，而这个引用就是闭包。  
**简单说就是外层函数调用后，外层函数作用域对象被返回的函数的作用域链引用着，无法释放，就形成了闭包。**  
**解除闭包**也很简单，直接将保存返回的内存函数的变量赋值为null即可。

我之前在思否上面看到过一个问题，觉得很有代表性：

```js
function foo(){
  var a= 2
  function bar(){
    console.log(a)
  }
  bar()
}
foo()
```

这是比闭包吗？

从前面的定义来说这个不是闭包，但是他基于词法作用域的查找规则，是闭包的一部分，非常重要的一部分。

这些代码都有些死板，只是为了解释如何使用闭包。
例如:

```js
function wait(msg){
  setTimeout(function timer(){
    console.log(msg)
  },1000)
}
wait('hello,closure')
```

上面的代码讲一个内部的函数timer传递给了setTimeout，timer可以访问wait的词法作用域，保留着对msg的引用。  
内置的工具函数setTimeout保持着对第一个参数的引用，就是timer，引擎会调用这个函数，而词法作用域在这个过程中保持完整。这就是闭包。  
日常中的定时器、事件监听器、ajax请求、跨窗口通信、web workers等任务中，只要使用了回调函数，实际上就是在使用闭包。  
闭包也可以用于模块化。  

### 闭包小结

当函数可以记住所在词法作用域时，即使是在当前词法作用域外执行，这时就产生了闭包。简单来说就是外层函数调用后，外层函数的作用域对象被返回的函数作用域引用着，无法释放，就形成了闭包。

### es6中的模块机制

es6会将文件当做独立的模块来处理。每个模块可以导入其他模块或特定的API成员，同样的也可以导出自己的API成员。  
上面说到的基于闭包的函数式的模块并不是静态的，编译器无法识别，只有在运行时才知道里面有什么。  
而es6的这种属于静态的，在编译阶段会进行检查，例如某些api引用不存在，会在编译的时候就抛出错误。  

- import
  - 导入
- export
  - 导出

## 其他补充

### 动态作用域

- 词法作用域在写代码或者说定义是确定的  
  - 作用域链基于代码中的作用域嵌套
- 而动态作用域是在运行时确定的
  - 不关心函数和作用域是如何声明的以及在何处
  - 只关心它们从何处调用的
  - 作用域链基于调用栈

### 块作用域的代替方案

try/catch来实现：

```
try{
  throw 2
}catch(a){
  console.log(a)//2
}
consloe.log(a)//referenceError
```

也可以使用匿名函数自调的方式实现
